#include <fstream>
#include <vector>
#include <iostream>
#include <cmath>
#include "random.h"
#include "error.h"

using namespace std;

int main (){


// DIRECT SAMPLING

   Random rnd;
   int seed[4];
   int p1, p2;
   ifstream Primes("Primes");
   if (Primes.is_open()){
      Primes >> p1 >> p2 ;
   } else cerr << "PROBLEM: Unable to open Primes" << endl;
   Primes.close();

   ifstream input("seed.in");
   string property;
   if (input.is_open()){
      while ( !input.eof() ){
         input >> property;
         if( property == "RANDOMSEED" ){
            input >> seed[0] >> seed[1] >> seed[2] >> seed[3];
            rnd.SetRandom(seed,p1,p2);
         }
      }
      input.close();
   } else cerr << "PROBLEM: Unable to open seed.in" << endl;


	double S0=100; // asset starting price
	double T=1;	// delivery time
	double K=100; // strike price
	double r=0.1; // risk-free interest rate
	double sigma=0.25, sigma2=sigma*sigma; // volatility

	int M=1e6, N=100, L=(M/N), k;
	double sum_call, sum_put;
	vector<double> x;
	vector<double> Cave_call (N,0.);
	vector<double> C2ave_call (N,0.);
	vector<double> sum_prog_call (N,0.);
	vector<double> sum2_prog_call (N,0.);
	vector<double> err_prog_call (N,0.);
	vector<double> Cave_put (N,0.);
	vector<double> C2ave_put (N,0.);
	vector<double> sum_prog_put (N,0.);
	vector<double> sum2_prog_put (N,0.);
	vector<double> err_prog_put (N,0.);
	vector<double> ST;


	for (int h=0; h<N; h++) x.push_back(h*L);
	for (int h=0; h<M; h++) ST.push_back(S0*exp((r-0.5*sigma2)*T+sigma*rnd.Gauss(0., T)));

	for(int i=0; i<N; i++){
		sum_call=0;
		sum_put=0;
		for (int j=0; j<L; j++){
			k=j+i*L;
			sum_call += exp(-r*T)*max(0., ST[k]-K);
			sum_put += exp(-r*T)*max(0., K-ST[k]);
		}
		Cave_call[i]=sum_call/L;
		C2ave_call[i]=Cave_call[i]*Cave_call[i];
		Cave_put[i]=sum_put/L;
		C2ave_put[i]=Cave_put[i]*Cave_put[i];
	}

	for(int i=0; i<N; i++){
		for (int j=0; j<(i+1); j++){
			sum_prog_call[i] += Cave_call[j];
			sum2_prog_call[i] += C2ave_call[j];
			sum_prog_put[i] += Cave_put[j];
			sum2_prog_put[i] += C2ave_put[j];
		}
		sum_prog_call[i] /= (i+1);
		sum2_prog_call[i] /= (i+1);
		err_prog_call[i]=error(sum_prog_call, sum2_prog_call, i);
		sum_prog_put[i] /= (i+1);
		sum2_prog_put[i] /= (i+1);
		err_prog_put[i]=error(sum_prog_put, sum2_prog_put, i);
	}

	ofstream out;
	out.open("direct_sampling.txt");

	for (int h=0; h<N; h++)
		out << x[h] << "	" << (sum_prog_call[h]) << "	" << err_prog_call[h] << "	" << (sum_prog_put[h]) << "	" << err_prog_put[h] << endl;

	out.close();

// DISCRETE STEPS SAMPLING

	int Nsteps=100;
	double Sti; // S at each step
	double tau=T/Nstep; // step width

	ST.clear();


	for (int h=0; h<N; h++) x.push_back(h*L);
	for (int h=0; h<M; h++){
		Sti=S0;
		for (int step=0; step<Nsteps; step++)
			Sti=Sti*exp((r-0.5*sigma2)*tau+sigma*rnd.Gauss(0., 1)*sqrt(tau));
		ST.push_back(Sti);
	}

	for(int i=0; i<N; i++){
		sum_call=0;
		sum_put=0;
		for (int j=0; j<L; j++){
			k=j+i*L;
			sum_call += exp(-r*T)*max(0., ST[k]-K);
			sum_put += exp(-r*T)*max(0., K-ST[k]);
		}
		Cave_call[i]=sum_call/L;
		C2ave_call[i]=Cave_call[i]*Cave_call[i];
		Cave_put[i]=sum_put/L;
		C2ave_put[i]=Cave_put[i]*Cave_put[i];
	}

	for(int i=0; i<N; i++){
		sum_prog_call[i] = 0;
		sum2_prog_call[i] = 0;
		sum_prog_put[i] = 0;
		sum2_prog_put[i] = 0;
		for (int j=0; j<(i+1); j++){
			sum_prog_call[i] += Cave_call[j];
			sum2_prog_call[i] += C2ave_call[j];
			sum_prog_put[i] += Cave_put[j];
			sum2_prog_put[i] += C2ave_put[j];
		}
		sum_prog_call[i] /= (i+1);
		sum2_prog_call[i] /= (i+1);
		err_prog_call[i]=error(sum_prog_call, sum2_prog_call, i);
		sum_prog_put[i] /= (i+1);
		sum2_prog_put[i] /= (i+1);
		err_prog_put[i]=error(sum_prog_put, sum2_prog_put, i);
	}

	ofstream out2;
	out2.open("discrete_sampling.txt");

	for (int h=0; h<N; h++)
		out2 << x[h] << "	" << (sum_prog_call[h]) << "	" << err_prog_call[h] << "	" << (sum_prog_put[h]) << "	" << err_prog_put[h] << endl;

	out2.close();

   rnd.SaveSeed();
	return 0;
}


