#include <iostream>
#include <fstream>
#include <cmath>
#include <iomanip>
#include "random.h"
#include "error.h"
#include "funzioneBase.h"

using namespace std;

Random rnd;

const int coolstep = 100;//Number of cooling steps
const int num = 100;//Number of MC steps at each beta
double beta [coolstep];
int n[coolstep];
int acceptedSA=0;//New values for the parameters accepted at each beta

const int nstep=1e5, equilstep=1e4, nblocks=100, blocksize=nstep/nblocks; //Data blocking constants
int step=0, accepted=0; //Metropolis total and accepted moves at each trial

double l=1.2;
double mu=1., sigma=0.5, energy;
double x=1.;
double ht=1., mass=1.;

FunzioneBase3D * prob = new square_psi_trial(mu, sigma);
double en [nblocks], av_en [nblocks], av2_en [nblocks], err_en [nblocks];
double sum;

ofstream out_energy_search;


double T (double y, double z);
double A (double y, double z);
void MetroStepUnif(FunzioneBase3D * p);
void MetroStepGauss(FunzioneBase3D * p);

void Initialize();
double Eloc(double y);
void SAStep(int istep);
double TrialEnergy();
void BestEnergy();


int main (){

	Initialize();

	out_energy_search.open("energy_search.out", ios::app);

	energy = TrialEnergy();
	for(int istep=0; istep<coolstep; istep++){
		acceptedSA=0;
		for(int m=0; m<n[istep]; m++){
			step=0;
			while(step<equilstep){ //This makes the metropolis equilibrate
				MetroStepUnif(prob);
			}
			SAStep(istep);
		}
//		cout << "The fraction of acceptance at step " << istep << " of the SA (beta=" << beta[istep] <<") is " << double(acceptedSA)/double(n[istep]) << endl;
			cout << "step " << istep+1 << " of " << coolstep << " completed" << endl;
	}

	out_energy_search.close();

	prob->Set(mu, sigma);
	BestEnergy();

  rnd.SaveSeed();

	return 0;
}


double T (double y, double z){
  if (abs(y-z)<l) return 1./(2*l);
  else return 0;
}

double A (double y, double z, FunzioneBase3D * p){
  return min(1., (p->Eval(y)/p->Eval(z)));
}

void MetroStepUnif(FunzioneBase3D * p){
  double y = x+l*rnd.Rannyu(-1,1);
  double r = rnd.Rannyu(), alpha = A(y, x, p);
  if(r<=alpha){
    x=y;
		accepted++;
   }
  step++;
}

void Initialize(){
//Set rnd
  int seed[4];
  int p1, p2;
  ifstream Primes("Primes");
  if (Primes.is_open()){
    Primes >> p1 >> p2 ;
  } else cerr << "PROBLEM: Unable to open Primes" << endl;
  Primes.close();

  ifstream input("seed.in");
  string property;
  if (input.is_open()){
    while ( !input.eof() ){
      input >> property;
      if( property == "RANDOMSEED" ){
        input >> seed[0] >> seed[1] >> seed[2] >> seed[3];
        rnd.SetRandom(seed,p1,p2);
      }
    }
    input.close();
  } else cerr << "PROBLEM: Unable to open seed.in" << endl;

//Set annealing schedule
	for(int istep=0; istep<coolstep; istep++){
		beta[istep] = (double)(istep+1)*5.;
		n[istep] = num;
	}
}


double Eloc(double y){
	double e = -ht*ht/(2.*mass)*(((y-mu)*(y-mu)/pow(sigma,4)-1./(sigma*sigma))*exp(-(y-mu)*(y-mu)/(2.*sigma*sigma))+((y+mu)*(y+mu)/pow(sigma,4)-1./(sigma*sigma))*exp(-(y+mu)*(y+mu)/(2.*sigma*sigma)))/(exp(-(y-mu)*(y-mu)/(2.*sigma*sigma))+exp(-(y+mu)*(y+mu)/(2.*sigma*sigma)))+(pow(y,4)-2.5*y*y);
	return e;
}

//Performs a SA step by generating a couple of new parameters, evaluating the average energy and accepting the change with probability alpha (see below)
void SAStep(int istep){
	double old_mu = mu, old_sigma = sigma;
	mu += rnd.Rannyu(-0.5, 0.5);
	sigma = max(0.1, sigma+rnd.Rannyu(-0.2, 0.2));

	prob->Set(mu, sigma);
	double new_energy = TrialEnergy();

	double alpha = min(1., exp(-beta[istep]*(new_energy-energy)));

	double r = rnd.Rannyu();
	if(r<alpha){
//cout << energy << " -> " << new_energy << " accepted at beta = " << beta[istep] << endl;
	out_energy_search << fixed << setprecision(5) << beta[istep] << "	" << mu << "	" << sigma << "	" << new_energy << endl;
		energy = new_energy;
		acceptedSA++;
	}
	else{
		mu = old_mu;
		sigma = old_sigma;
	}
}

//Computes the block average energy with the current parameters and adds mu, sigma and ave_energy to "energy_search.out", returns the average for all blocks
double TrialEnergy(){ //Remember: always call prob->Set(mu, sigma); before calling TrialEnergy
	step=0;
	accepted=0;
	double ave_energy=0.;
  for(int iblock=0; iblock<nblocks; iblock++){
		sum=0.;
		for(int i=0; i<blocksize; i++){
   		MetroStepUnif(prob);
			sum += Eloc(x)/blocksize;
		}
		en[iblock] = sum;
		ave_energy+=en[iblock]/nblocks;
	}
//	cout << "The fraction of acceptance in sampling psi square is " << double(accepted)/double(nstep) << endl;

	return ave_energy;
}

//Computes the block average energy with the current parameters mu and sigma and writes the points sampled by Metropolis in "points.out" and the block averages and errors in "energy.out"
void BestEnergy(){ //Remember: always call prob->Set(mu, sigma); before calling BestEnergy

	ofstream out_points, out_energy;
	out_points.open("points.out");
	out_energy.open("energy.out");
	step=0;
	accepted=0;
  for(int iblock=0; iblock<nblocks; iblock++){
		sum=0.;
		av_en[iblock]=0.;
		av2_en[iblock]=0.;
		for(int i=0; i<blocksize; i++){
   		MetroStepUnif(prob);
			sum += Eloc(x);
			out_points << x << endl;
		}
		en[iblock] = sum/blocksize;
		for(int jblock=0; jblock<=iblock; jblock++){
			av_en[iblock] += en[jblock];
			av2_en[iblock] += en[jblock]*en[jblock];
		}
		av_en[iblock] /= (iblock+1);
		av2_en[iblock] /= (iblock+1);
		err_en[iblock] = error(av_en, av2_en, iblock);

		out_energy << av_en[iblock] << "	" << err_en[iblock] << endl;
	}
	out_points.close();
	out_energy.close();


//	cout << "The fraction of acceptance in sampling psi square is " << double(accepted)/double(nstep) << endl;

	cout << endl << "The best values for the parameters are:" << endl << "mu = " << mu << endl << "sigma = " << sigma << endl << "The variational ground state energy is " << av_en[nblocks-1] << endl << endl;
}



